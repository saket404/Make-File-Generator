/**************************************************
* generator.c
* Created by: Prathiphan Dubey 57070503454 (Lucky)
*             Saket Khandelwal 57070503483
**************************************************
*/
#include "generator.h"
#include <time.h>
#include "function_scanner.h"

#if defined(WIN32) || defined(_WIN32)
#include <windows.h>
#elif defined(linux) || defined(__linux)
#include <unistd.h>
#include <dirent.h>
#endif

/*******************************************************************************
Free memory allocated for generator data source tree
Input:
	genData: generator data
Return:
	void
*******************************************************************************/
void Generator_FreeGeneratorSrcTree(BST* bst)
    {
    if (bst)
        {
        Generator_FreeGeneratorSrcTree(bst->greater);
        Generator_FreeGeneratorSrcTree(bst->lesser);
        if (bst->value)
            {
            StrHashFree((STR_HASH_TABLE*)bst->value);
            free(bst->value);
            }
        if (bst->key)
            free(bst->key);
        free(bst);
        }
    }
/*******************************************************************************
Free memory allocated for generator data
Input:
	genData: generator data
Return:
	void
*******************************************************************************/
void Generator_FreeGeneratorData(GENERATOR_DATA *genData)
    {
    BstFree(genData->fnTree);
    Generator_FreeGeneratorSrcTree(genData->srcTree);
    StrListFree(genData->mainSrcFiles);
    free(genData);
    }

/*******************************************************************************
Build graph representing the source file dependency
Input:
	strList: pointer to the source file list returned by the graph
	genData: generator data to generate makefiles
	visitedSrc: hash table mark visited source files
	initialSrcName: the initialize source file name
					(containing the "main" function)
Return:
	1 if successful
	0 otherwise
*******************************************************************************/
int Generator_BuildDependencyGraph(
    STR_LIST **strList,
    GENERATOR_DATA *genData,
    STR_HASH_TABLE *visitedSrc,
    const char *initialSrcName)
    {
    BST* srcNode;
    BST* fnNode;
    int i;
    STR_HASH_TABLE *fnTable;
    STR_HASH_ENTRY *fnEntry;
    const char *srcName;

    if (genData == NULL || initialSrcName == NULL || initialSrcName[0] == 0)
        return 0;

    if (StrHashSearch(visitedSrc, initialSrcName))
        return 1;	/* Source file already visited */

    /* Add source file to list of source files */
    if (!StrListInsertTail(strList, initialSrcName))
        return 0;

    /* Mark source file as visited */
    StrHashUpdate(visitedSrc, initialSrcName, NULL, 0);

    srcNode = BstSearch(genData->srcTree, initialSrcName);
    if (srcNode == NULL || srcNode->value == NULL)
        return 0;

    /* Loop through all functions that the source file references to */
    fnTable = (STR_HASH_TABLE*)srcNode->value;
    for (i = 0; i < STR_HASH_MAX_ELEMENTS; i++)
        {
        fnEntry = fnTable->hashEntry[i];
        while (fnEntry)
            {
            if (strcmp(fnEntry->key, "main"))	/* Skip the function "main" */
                {
                /* Search for function node */
                fnNode = BstSearch(genData->fnTree, fnEntry->key);
                if (fnNode)
                    {
                    /* Function found, find which file implements it */
                    srcName = (char*)fnNode->value;
                    if (srcName == NULL)
                        return 0;

                    /* Go deeper to the file */
                    if (!Generator_BuildDependencyGraph(
                                strList,
                                genData,
                                visitedSrc,
                                srcName))
                        return 0;
                    }
                }
            fnEntry = fnEntry->next;
            }
        }
    return 1;
    }

/*******************************************************************************
Write makefile header
Input:
	makeFile: the makefile object
	srcDir: source directory
Return:
	1 if successful
	0 otherwise
*******************************************************************************/
int Generator_WriteMakeFileHeader(
    FILE* makeFile,
    const char *srcDir)
    {
    const char* header = "# This makefile was automatically generated by "
                         "makefile_generator program,\n"
                         "# written by the Dayzers team\n";
    const char *osCheck = "ifeq ($(OSTYPE),WINDOWS)\n"
                          "\tEXECEXT  =.exe\n"
                          "\tCOMP     =__MINGCC__\n"
                          "\tPLATFORM =mingw\n"
                          "else\n"
                          "\tEXECEXT  =\n"
                          "\tCOMP     =__GCC__\n"
                          "\tPLATFORM =linux\n"
                          "endif\n\n";

    char timeInfo[100];

    time_t sysTime;

    if (makeFile == NULL || srcDir == NULL || srcDir[0] == 0)
        return 0;

    /* Header */
    if (fprintf(makeFile, "%s", header) <= 0)
        return 0;

    /* Source directory */
    if (fprintf(makeFile, "# Source directory: %s\n", srcDir) <= 0)
        return 0;

    /* Date time */
    sysTime = time(NULL);

    strftime(timeInfo, 100, "%Y-%m-%d %H:%M:%S", localtime(&sysTime));
    if (fprintf(makeFile, "# Generated at: %s\n", timeInfo) <= 0)
        return 0;

    if (fprintf(makeFile, "\n") <= 0)
        return 0;

    /* Operating system checking */
    if (fprintf(makeFile, "%s", osCheck) <= 0)
        return 0;

    return 1;
    }

/*******************************************************************************
Write makefile footer
Input:
	makeFile: the makefile object
Return:
	1 if successful
	0 otherwise
*******************************************************************************/
int Generator_WriteMakeFileFooter(FILE* makeFile)
    {
    if (makeFile == NULL)
        return 0;

    if (fprintf(makeFile, "# End of makefile") <= 0)
        return 0;

    return 1;
    }

/*******************************************************************************
Write the "all" configuration to makefile
Input:
	makeFile: the makefile object
	execList: list of executables file generated
Return:
	1 if successful
	0 otherwise
*******************************************************************************/
int Generator_WriteMakeFileAllConfig(
    FILE* makeFile,
    STR_LIST* execList)
    {
    STR_LIST *node;

    if (makeFile == NULL || execList == NULL)
        return 0;

    if (fprintf(makeFile, "EXECUTABLES = ") <= 0)
        return 0;

    node = execList;
    while (node)
        {
        if (fprintf(
                    makeFile,
                    "%s$(EXECEXT)%s",
                    node->value,
                    node->next ? " " : "\n\n") <= 0)
            return 0;

        node = node->next;
        }

    if (fprintf(makeFile, "all: $(EXECUTABLES)\n\n") <= 0)
        return 0;
    return 1;
    }

/*******************************************************************************
Write the "clean" configuration to makefile
Input:
	makeFile: the makefile object
Return:
	1 if successful
	0 otherwise
*******************************************************************************/
int Generator_WriteMakeFileCleanConfig(FILE* makeFile)
    {
    if (makeFile == NULL)
        return 0;

    if (fprintf(makeFile, "clean:\n\t-rm *.o\n\t-rm $(EXECUTABLES)\n") <= 0)
        return 0;

    if (fprintf(makeFile, "\n") <= 0)
        return 0;
    return 1;
    }

/*******************************************************************************
Write configuration for the given executable
Input:
	srcList: list of source files
	outputName: the output (executable) of the makefile
	makeFile: the makefile object
Return:
	1 if successful
	0 otherwise
*******************************************************************************/
int Generator_WriteMakeFileExecutableConfiguration(
    STR_LIST *srcList,
    const char *outputName,
    FILE* makeFile)
    {
    STR_LIST *srcFile;

    if (srcList == NULL ||
            outputName == NULL || outputName[0] == 0 ||
            makeFile == NULL)
        return 0;

    /* Write dependencies */
    if (fprintf(makeFile, "%s$(EXECEXT): ", outputName) <= 0)
        {
        fclose(makeFile);
        return 0;
        }

    srcFile = srcList;
    while (srcFile)
        {
        if (fprintf(makeFile, srcFile->next ? "%s " : "%s\n",
                    srcFile->value) <= 0)
            {
            fclose(makeFile);
            return 0;
            }
        srcFile = srcFile->next;
        }

    /* Then write gcc command */
    if (fprintf(makeFile, "\tgcc -o %s$(EXECEXT) ", outputName) <= 0)
        return 0;

    /* Then write list of source files */
    srcFile = srcList;
    while (srcFile)
        {
        if (fprintf(makeFile, srcFile->next ? "%s " : "%s\n\n",
                    srcFile->value) <= 0)
            return 0;

        srcFile = srcFile->next;
        }

    return 1;
    }

/*******************************************************************************
Get the output make file path based on source directory and makefile file name
Input:
	srcDir: source directory
	makefileName: makefile file name (usually "makefile")
Return:
	pointer to the newly allocated buffer for the output file path
	NULL if an error occurred
*******************************************************************************/
char* Generator_MakeFilePath(
    const char *srcDir,
    const char *makeFileName)
    {
    char *outputName;
    size_t len;
    int needSlash = 0;

    if (srcDir == NULL || srcDir[0] == 0 ||
            makeFileName == NULL || makeFileName[0] == 0)
        return NULL;

    len = strlen(srcDir);
    if (len > 0 && srcDir[len - 1] != PATH_SEPARATOR_CHAR)
        {
        len++;
        needSlash = 1;
        }
    len += strlen(makeFileName);

    outputName = (char*)calloc(sizeof(char), len + 1);
    if (outputName == NULL)
        return NULL;

    strcpy(outputName, srcDir);
    if (needSlash)
        strcat(outputName, PATH_SEPARATOR_STRING);
    strcat(outputName, makeFileName);
    outputName[len] = 0;

    return outputName;
    }


/*******************************************************************************
Get the output (program) file name from source file
Input:
	mainSrcFile: path of the source file containing the main function
Return:
	pointer to the newly allocated buffer for the output file name
	NULL if an error occurred
*******************************************************************************/
char* Generator_GetOutputFile(const char *mainSrcFile)
    {
    const char *startPos;
    char *outputName;
    size_t len;

    if (mainSrcFile == NULL || mainSrcFile[0] == 0)
        return NULL;

    startPos = strrchr(mainSrcFile, '/');
    if (startPos == NULL)
        startPos = mainSrcFile;

    len = strlen(startPos);
    if (len > 2 &&
            startPos[len - 2] == '.' &&
            startPos[len - 1] == 'c')
        /* File name has the ".c" extension */
        len -= 2;

    outputName = (char*)calloc(sizeof(char), len + 1);
    if (outputName == NULL)
        return NULL;

    strncpy(outputName, startPos, len);
    outputName[len] = 0;

    return outputName;
    }

/*******************************************************************************
Generate make file based on the internal generator data
Input:
	genData: generator data to generate makefiles
	srcDir: source directory
Return:
	-1 if any error occurred
	otherwise the number of executable(s) in makefile generated
*******************************************************************************/
int Generator_Generate(GENERATOR_DATA *genData, const char *srcDir)
    {
    STR_LIST *strList;
    STR_LIST *mainSrcFile;
    STR_LIST *execList = NULL;
    char *makeFilePath;
    FILE *makeFile;
    STR_HASH_TABLE *visitedSrc;	/* Mark visited source file */
    unsigned int idx = 0;
    int makeFileGenerated = 0;
    char* outputName;

    if (genData->fnTree == NULL || genData->srcTree == NULL)
        return -1;

    makeFilePath = Generator_MakeFilePath(srcDir, "makefile");
    if (makeFilePath == NULL)
        return -1;

    makeFile = fopen(makeFilePath, "wt");
    free(makeFilePath);
    if (makeFile == NULL)
        return -1;

    if (!Generator_WriteMakeFileHeader(makeFile, srcDir))
        {
        fclose(makeFile);
        return -1;
        }

    /* Process every source file that references to the main function */
    mainSrcFile = genData->mainSrcFiles;
    while (mainSrcFile)
        {
        strList = NULL;
        visitedSrc = (STR_HASH_TABLE*)calloc(1, sizeof(STR_HASH_TABLE));
        if (visitedSrc == NULL)
            continue;
        if (Generator_BuildDependencyGraph(
                    &strList,
                    genData,
                    visitedSrc,
                    mainSrcFile->value))
            {
            outputName = Generator_GetOutputFile(mainSrcFile->value);
            if (outputName)
                {
                if (Generator_WriteMakeFileExecutableConfiguration(
                            strList,
                            outputName,
                            makeFile))
                    {
                    StrListInsertTail(&execList, outputName);
                    makeFileGenerated++;
                    }
                free(outputName);
                }

            }
        StrHashFree(visitedSrc);
        free(visitedSrc);
        StrListFree(strList);
        idx++;
        mainSrcFile = mainSrcFile->next;
        }

    if (execList &&
            (!Generator_WriteMakeFileAllConfig(makeFile, execList) ||
             !Generator_WriteMakeFileCleanConfig(makeFile)))
        {
        StrListFree(execList);
        fclose(makeFile);
        return -1;
        }

    if (execList)
        StrListFree(execList);

    if (!Generator_WriteMakeFileFooter(makeFile))
        {
        fclose(makeFile);
        return -1;
        }
    fclose(makeFile);
    return makeFileGenerated;
    }

#if defined(WIN32) || defined(_WIN32)
/*******************************************************************************
Generate make file from the given source directory for the Windows platform
Input:
	srcDir: source directory
	genData: generator internal data
Return:
	-1 if any error occurred
	otherwise the number of executable files generated
*******************************************************************************/
int Generator_GenerateMakeFileWin32(
    const char *srcDir,
    GENERATOR_DATA *genData)
    {
    WIN32_FIND_DATA	wfd;
    char *filePath;
    HANDLE hFind;
    int scanResult;

    /* Enumerate .c source files in the given source directory */
    filePath = Generator_MakeFilePath(srcDir, "*.c");
    if (filePath == NULL) return -1;
    hFind = FindFirstFile(filePath, &wfd);
    free(filePath);

    if (hFind == INVALID_HANDLE_VALUE)
        return 0;

    do
        {
        if (strcmp(wfd.cFileName, ".") == 0 ||
                strcmp(wfd.cFileName, "..") == 0 ||
                (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
            continue;

        filePath = Generator_MakeFilePath(srcDir, wfd.cFileName);
        if (filePath)
            {
            printf("Scanning file %s ...\n", filePath);
            scanResult = FnScanner_ScanSrcFile(filePath, wfd.cFileName, genData);
            free(filePath);
            if (scanResult == -1)
                break;
            }
        }
    while (FindNextFile(hFind, &wfd));
    FindClose(hFind);

    if (scanResult == -1)
        return -1;

    /* Then we generate the dependency graph based on our internal generator data */
    return Generator_Generate(genData, srcDir);
    }

#elif defined(linux) || defined(__linux)
/*******************************************************************************
Filter function for source directory scanner
Input:
	dirEntry: directory entry to filter
Return:
	1 if the given entry passes the filter
	0 otherwise
*******************************************************************************/
int Generator_FilterFile(const struct dirent* dirEntry)
    {
    const char *pos;
    if (dirEntry == NULL) return 0;

    pos = strrchr(dirEntry->d_name, '.');
    if (pos == NULL) return 0;

    return (strcmp(pos, ".c") == 0);
    }
/*******************************************************************************
Generate make file from the given source directory for the Linux platform
Input:
	srcDir: source directory
	genData: generator internal data
Return:
	-1 if any error occurred
	otherwise the number of executable files generated
*******************************************************************************/
int Generator_GenerateMakeFileLinux(
    const char *srcDir,
    GENERATOR_DATA *genData)
    {
    struct dirent** dirList = NULL;
    char *filePath;
    char *fileName;
    int cnt;
    int i;
    int scanResult;

    if (srcDir == NULL || genData == NULL) return -1;

    cnt = scandir(srcDir, &dirList, Generator_FilterFile, alphasort);
    if (cnt < 0) return -1;

    for (i = 0; i < cnt; i++)
        {
        fileName = dirList[i]->d_name;
        filePath = Generator_MakeFilePath(srcDir, fileName);

        if (filePath)
            {
            printf("Scanning file %s ...\n", fileName);
            scanResult = FnScanner_ScanSrcFile(filePath, fileName, genData);
            free(filePath);
            if (scanResult == -1)
                break;
            }
        }
    if (dirList)
        free(dirList);

    if (scanResult == -1)
        return -1;

    /* Then we generate the dependency graph based on our internal generator data */
    return Generator_Generate(genData, srcDir);
    }

#endif

/*******************************************************************************
Generate make file from the given source directory
Input:
	srcDir: source directory
Return:
	-1 if any error occurred
	otherwise the number of executable files generated
*******************************************************************************/
int Generator_GenerateMakeFile(const char *srcDir)
    {
    GENERATOR_DATA *genData;
    int result;

    genData = (GENERATOR_DATA*)calloc(1, sizeof(GENERATOR_DATA));
    if (genData == NULL)
        return -1;
#if defined(WIN32) || defined(_WIN32)
    result = Generator_GenerateMakeFileWin32(srcDir, genData);
#elif defined (linux) || defined(__linux)
    result = Generator_GenerateMakeFileLinux(srcDir, genData);
#else
#error Unknown platform
#endif
    Generator_FreeGeneratorData(genData);

    return result;
    }
